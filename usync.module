<?php
/**
 * @file
 * ÂµSync module.
 */

use USync\AST\NodeInterface;
use USync\AST\Visitor;
use USync\AST\Processing\DrupalAttributesProcessor;
use USync\AST\Processing\DrupalProcessor;
use USync\AST\Processing\ExpressionProcessor;
use USync\AST\Processing\InheritProcessor;
use USync\AST\Path;
use USync\Context;
use USync\Parsing\PathDiscovery;
use USync\Parsing\YamlReader;
use USync\TreeBuilding\ArrayTreeBuilder;

/**
 * View mode variable nae.
 */
const USYNC_VAR_VIEW_MODE = 'usync_view_mode';

/**
 * Load the composer autoload, be flexible about it, it might be elsewhere.
 */
@include_once __DIR__ . '/vendor/autoload.php';

/**
 * Load compatibility layer with other modules.
 */
require_once __DIR__ . '/usync.compat.inc';

/**
 * Implements hook_hook_info().
 */
function usync_hook_info() {
  return [
    'usync_loader_list_alter' => [
      'group' => 'usync',
    ],
    'usync_path_map' => [
      'group' => 'usync',
    ],
    'usync_path_map_alter' => [
      'group' => 'usync',
    ],
  ];
}

/**
 * Implements hook_entity_info_alter().
 */
function usync_entity_info_alter(&$entity_info) {
  // @todo Export other entity options.
  // Export view modes we found during synchronization.
  foreach (variable_get(USYNC_VAR_VIEW_MODE, array()) as $entity_type => $view_modes) {
    if (isset($entity_info[$entity_type])) {
      // @todo Add a "strict" mode that disables all other view modes.
      foreach ($view_modes as $name => $label) {
        $entity_info[$entity_type]['view modes'][$name] = array(
          'label' => $label,
          'custom settings' => true
        );
      }
    }
  }
}

/**
 * Find modules implementing our own hook.
 *
 * @return string[][]
 *   First dimension keys are module internal names, values are arrays
 *   of listed sources, a source is supposed to be a file or directory
 *   path relative to the module root.
 */
function usync_module_list() {
  $ret = [];

  foreach (system_list('module_enabled') as $module => $data) {
    if (!empty($data->info['usync'])) {

      $sources = $data->info['usync'];
      // For lazy people this module allows to declare only one source
      // not using the info array form ([]). Lazy people are lazy there
      // is no point in fighting against them.
      if (!is_array($sources)) {
        $sources = [$sources];
      }

      $ret[$module] = $sources;
    }
  }

  return $ret;
}

/**
 * Fetch all known loader instances.
 *
 * @return \USync\Loading\LoaderInterface[]
 */
function usync_loader_list() {

  // Core loaders
  $instanceLoader = new \USync\Loading\FieldInstanceLoader();
  $loaders = [
    new \USync\Loading\FieldLoader($instanceLoader),
    new \USync\Loading\MenuItemLoader(),
    new \USync\Loading\MenuLoader(),
    new \USync\Loading\NodeEntityLoader(),
    $instanceLoader,
    new \USync\Loading\RoleLoader(),
    new \USync\Loading\ViewModeLoader(),
    new \USync\Loading\VariableLoader(),
    new \USync\Loading\VocabularyEntityLoader(),
  ];

  if ($moduleLoaders = module_invoke_all(__FUNCTION__)) {
    $loaders = array_merge($moduleLoaders, $loaders);
  }
  drupal_alter(__FUNCTION__, $loaders);

  return $loaders;
}

/**
 * Create a graph from the given sources.
 *
 * @param string[] $sources
 *   Array of file or directory paths.
 * @param string $type
 *   Datatype to look for.
 *   @deprecated
 *   @todo Move the 'type' switch into each source
 *
 * @return \USync\AST\NodeInterface
 *   Merged graph of everything.
 */
function usync_graph_create($sources, $type = 'yaml') {
  $full = array();

  foreach ($sources as $source) {

    if (!is_dir($source) && !is_file($source)) {
      trigger_error(sprintf("%s: file does not exists", $source));
      return false;
    }

    if (!empty($type)) {
      $readerClass = '\\USync\\Parsing\\' . ucfirst($type) . 'Reader';
      if (!class_exists($readerClass)) {
        trigger_error(sprintf("'%s': type is not supported", $type));
        return false;
      }
      $reader = new $readerClass();
    } else {
      $reader = new YamlReader();
    }

    if (is_file($source)) {
      $data = $reader->read($source);
    } else if (is_dir($source)) {
      $discovery = new PathDiscovery();
      $data = $discovery->discover($source, $reader);
    }

    if (empty($data)) {
      triggger_error(sprintf("%s: Could not parse file or folder", $source));
      return false;
    }

    $full = drupal_array_merge_deep($full, $data);
  }

  return (new ArrayTreeBuilder())->parse($full);
}

/**
 * Get graph from the given module.
 *
 * @param string $module
 *   The module for which to get the graph.
 * @param string[] $sources
 *   List of module declared source names you want to join into this graph.
 *
 * @return \USync\AST\NodeInterface
 *   The graph.
 */
function usync_module_graph_get($module, array $sources = null) {

  $list = usync_module_list();

  if (!module_exists($module)) {
    trigger_error(sprintf("%s is not enable or does not exist", $module));
    return false;
  }
  if (!isset($list[$module])) {
    trigger_error(sprintf("%s does not declare any synchronization sources", $module));
    return false;
  }

  if (null === $sources) {
    $sources = $list[$module];
  }

  $path = drupal_get_path('module', $module);

  foreach ($sources as $index => $source) {
    if (!in_array($source, $list[$module])) {
      trigger_error(sprintf("%s does not declare the '%s' source", $module, $source));
      return false;
    }
    $sources[$index] = $path . '/' . $source;
  }

  return usync_graph_create($sources);
}

/**
 * Run sync.
 *
 * You may call this during your updates, it does work.
 *
 * Synchronization is embeded into a transaction but please be aware that any
 * DDL operations (table alteration mostly) won't be rollbacked.
 *
 * @param string $module
 *   The module for which to get the graph.
 * @param string[] $sources
 *   List of module declared source names you want to join into this graph.
 * @param string|string[] $pathes
 *   Can be null, a single pattern or an array of patterns to match
 * @param string $partial
 *   Please ignore this parameter for now.
 */
function usync_run($module, $sources = null, $patterns = null, $partial = false) {

  if ($sources && !is_array($sources)) {
    $sources = [$sources];
  }
  if ($patterns && !is_array($patterns)) {
    $patterns = [$patterns];
  }

  $tx = null;

  try {
    $tx = db_transaction();

    $graph = usync_module_graph_get($module, $sources);
    if (!$graph) {
      throw new \InvalidArgumentException("Invalid sources provided");
    }

    $loaders = usync_loader_list();
    $context = new Context($graph);

    $visitor = new Visitor();
    $visitor->addProcessor(new ExpressionProcessor());
    $visitor->addProcessor(new DrupalAttributesProcessor());
    $visitor->addProcessor(new InheritProcessor());
    $visitor->execute($graph, $context);

    $visitor = new Visitor(Visitor::TOP_BOTTOM);
    $drupalProcessor = new DrupalProcessor($loaders);

    if (null !== $patterns) {
      $visitor->addProcessor(function (NodeInterface $node, Context $context) use ($drupalProcessor, $patterns, $partial) {
        foreach ($patterns as $pattern) {
          if (false !== Path::match($node->getPath(), $pattern, $partial)) {
            $drupalProcessor->execute($node, $context);
          }
        }
      });
    } else {
      $visitor->addProcessor($drupalProcessor);
    }

    $visitor->execute($graph, $context);

    // This seems, at some point, mandatory.
    field_cache_clear();
    // DO NOT EVER call menu_rebuild() manually, if you do this, Drupal will
    // mix-up the menu links you manually saved using menu_link_save() and
    // those still in cache at some point, and loose menu items parenting.
    // This wrong behavior cost me a few hours to debug.
    variable_set('menu_rebuild_needed', 1);

    unset($tx); // Explicit commit.

  } catch (\Exception $e) {
    if ($tx) {
      try {
        $tx->rollback();
      } catch (Exception $e2) {}
    }
    throw $e;
  }
}
