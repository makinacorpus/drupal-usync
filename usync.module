<?php
/**
 * @file
 * ÂµSync module.
 */

use USync\AST\NodeInterface;
use USync\AST\Visitor;
use USync\AST\Processing\DrupalAttributesProcessor;
use USync\AST\Processing\DrupalProcessor;
use USync\AST\Processing\ExpressionProcessor;
use USync\AST\Processing\InheritProcessor;
use USync\AST\Path;
use USync\Context;
use USync\TreeBuilding\GraphBuilder;

/**
 * View mode variable nae.
 */
const USYNC_VAR_VIEW_MODE = 'usync_view_mode';

/**
 * Load the composer autoload, be flexible about it, it might be elsewhere.
 */
@include_once __DIR__ . '/vendor/autoload.php';

/**
 * Load compatibility layer with other modules.
 */
require_once __DIR__ . '/usync.compat.inc';

/**
 * Implements hook_hook_info().
 */
function usync_hook_info() {
  return [
    'usync_loader_list_alter' => [
      'group' => 'usync',
    ],
    'usync_path_map' => [
      'group' => 'usync',
    ],
    'usync_path_map_alter' => [
      'group' => 'usync',
    ],
  ];
}

/**
 * Implements hook_entity_info_alter().
 */
function usync_entity_info_alter(&$entity_info) {
  // @todo Export other entity options.
  // Export view modes we found during synchronization.
  foreach (variable_get(USYNC_VAR_VIEW_MODE, array()) as $entity_type => $view_modes) {
    if (isset($entity_info[$entity_type])) {
      // @todo Add a "strict" mode that disables all other view modes.
      foreach ($view_modes as $name => $label) {
        // If the view mode is not already created by another module
        if (!isset($entity_info[$entity_type]['view modes'][$name])) {
          // Declare it but without being required by default
          $entity_info[$entity_type]['view modes'][$name] = array(
            'label' => $label,
            'custom settings' => false
          );
        }
      }
    }
  }
}

/**
 * Fetch all known loader instances.
 *
 * @return \USync\Loading\LoaderInterface[]
 */
function usync_loader_list() {

  // Core loaders
  $instanceLoader = new \USync\Loading\FieldInstanceLoader();
  $loaders = [
    new \USync\Loading\InputFilterLoader(),
    new \USync\Loading\ImageStyleLoader(),
    new \USync\Loading\FieldLoader($instanceLoader),
    new \USync\Loading\MenuItemLoader(),
    new \USync\Loading\NodeEntityLoader(),
    $instanceLoader,
    new \USync\Loading\RoleLoader(),
    new \USync\Loading\ViewModeLoader(),
    new \USync\Loading\VariableLoader(),
    new \USync\Loading\VocabularyEntityLoader(),
  ];

  if (module_exists('menu')) {
    $loaders[] = new \USync\Loading\MenuLoader();
  }
  elseif(module_exists('umenu')) {
    $loaders[] = new \USync\Loading\UMenuLoader(umenu_get_storage());
  }

  if ($moduleLoaders = module_invoke_all(__FUNCTION__)) {
    $loaders = array_merge($moduleLoaders, $loaders);
  }
  drupal_alter(__FUNCTION__, $loaders);

  // Allow loaders to set up the environment.
  foreach ($loaders as $loader) {
    /* @var $loader \USync\Loading\LoaderInterface */
    $loader->init();
  }

  return $loaders;
}

/**
 * @deprecated
 */
function usync_run($module, $sources = null, $patterns = null, $partial = false) {

  $parsed = [];

  if ($sources) {
    if (!is_array($sources)) {
      $sources = [$sources];
    }
    foreach ($sources as $target) {
      $parsed[] = $module . ':' . $target;
    }
  } else {
    $parsed[] = $module . ':';
  }

  return usync_run_sources($parsed, $patterns, $partial);
}

/**
 * Run sync.
 *
 * You may call this during your updates, it does work.
 *
 * Synchronization is embeded into a transaction but please be aware that any
 * DDL operations (table alteration mostly) won't be rollbacked.
 *
 * @param string $module
 *   The module for which to get the graph.
 * @param string[] $sources
 *   List of module declared source names you want to join into this graph.
 * @param string|string[] $pathes
 *   Can be null, a single pattern or an array of patterns to match
 * @param string $partial
 *   Please ignore this parameter for now.
 */
function usync_run_sources($sources = null, $patterns = null, $partial = false) {

  if ($sources && !is_array($sources)) {
    $sources = [$sources];
  }
  if ($patterns && !is_array($patterns)) {
    $patterns = [$patterns];
  }

  $tx = null;

  try {
    $tx = db_transaction();

    $graph = (new GraphBuilder($sources))->build();

    if (!$graph) {
      throw new \InvalidArgumentException("Invalid sources provided");
    }

    $loaders = usync_loader_list();
    $context = new Context($graph);

    $visitor = new Visitor();
    $visitor->addProcessor(new ExpressionProcessor());
    $visitor->addProcessor(new DrupalAttributesProcessor());
    $visitor->addProcessor(new InheritProcessor());
    $visitor->execute($graph, $context);

    $visitor = new Visitor(Visitor::TOP_BOTTOM);
    $drupalProcessor = new DrupalProcessor($loaders);

    if (null !== $patterns) {
      $visitor->addProcessor(function (NodeInterface $node, Context $context) use ($drupalProcessor, $patterns, $partial) {
        foreach ($patterns as $pattern) {
          if (false !== Path::match($node->getPath(), $pattern, $partial)) {
            $drupalProcessor->execute($node, $context);
          }
        }
      });
    } else {
      $visitor->addProcessor($drupalProcessor);
    }

    $visitor->execute($graph, $context);

    // This seems, at some point, mandatory.
    field_cache_clear();
    // DO NOT EVER call menu_rebuild() manually, if you do this, Drupal will
    // mix-up the menu links you manually saved using menu_link_save() and
    // those still in cache at some point, and loose menu items parenting.
    // This wrong behavior cost me a few hours to debug.
    variable_set('menu_rebuild_needed', 1);

    unset($tx); // Explicit commit.

  } catch (\Exception $e) {
    if ($tx) {
      try {
        $tx->rollback();
      } catch (Exception $e2) {}
    }
    throw $e;
  }
}
